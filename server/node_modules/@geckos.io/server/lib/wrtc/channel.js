"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bridge_1 = __importDefault(require("@geckos.io/common/lib/bridge"));
var eventemitter3_1 = __importDefault(require("eventemitter3"));
var parseMessage_1 = __importDefault(require("@geckos.io/common/lib/parseMessage"));
var constants_1 = require("@geckos.io/common/lib/constants");
var sendMessage_1 = __importDefault(require("@geckos.io/common/lib/sendMessage"));
var ServerChannel = /** @class */ (function () {
    function ServerChannel(webrtcConnection, dataChannelOptions) {
        var _this = this;
        this.eventEmitter = new eventemitter3_1.default();
        this._id = webrtcConnection.id;
        this._roomId = undefined;
        var _a = dataChannelOptions.label, label = _a === void 0 ? 'geckos.io' : _a, _b = dataChannelOptions.ordered, ordered = _b === void 0 ? false : _b, _c = dataChannelOptions.maxRetransmits, maxRetransmits = _c === void 0 ? 0 : _c, _d = dataChannelOptions.maxPacketLifeTime, maxPacketLifeTime = _d === void 0 ? undefined : _d;
        this.dataChannel = webrtcConnection.peerConnection.createDataChannel(label, {
            ordered: ordered,
            maxRetransmits: maxRetransmits,
            maxPacketLifeTime: maxPacketLifeTime
        });
        this.dataChannel.binaryType = 'arraybuffer';
        this.dataChannel.onopen = function () {
            _this.dataChannel.onmessage = function (ev) {
                var _a = parseMessage_1.default(ev), key = _a.key, data = _a.data;
                _this.eventEmitter.emit(key, data);
            };
            // if the dataChannel is open we can safely emit that we have a new open connection
            bridge_1.default.emit(constants_1.EVENTS.CONNECTION, _this);
        };
        this.dataChannel.onclose = function () {
            _this.eventEmitter.removeAllListeners();
        };
    }
    Object.defineProperty(ServerChannel.prototype, "id", {
        /** Get the channel's id. */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServerChannel.prototype, "roomId", {
        /** Get the channel's roomId. */
        get: function () {
            return this._roomId;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Listen for the disconnect event.
     * @param callback The event callback.
     */
    ServerChannel.prototype.onDisconnect = function (callback) {
        this.eventEmitter.on(constants_1.EVENTS.DISCONNECT, function (channel) {
            var cb = function (channel) { return callback(channel); };
            cb(channel);
        });
    };
    /** Join a room by its id. */
    ServerChannel.prototype.join = function (roomId) {
        this._roomId = roomId;
    };
    /** Leave the current room. */
    ServerChannel.prototype.leave = function () {
        this._roomId = undefined;
    };
    Object.defineProperty(ServerChannel.prototype, "room", {
        /** Emit a message to all channels in the same room. */
        get: function () {
            var _this = this;
            return {
                /**
                 * Emit a message to the current room.
                 * @param eventName The event name.
                 * @param data The data to send.
                 */
                emit: function (eventName, data) {
                    var _a;
                    bridge_1.default.emit(constants_1.EVENTS.SEND_TO_ROOM, (_a = {}, _a[eventName] = data, _a), {
                        id: _this._id,
                        roomId: _this._roomId
                    });
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServerChannel.prototype, "broadcast", {
        /** Broadcast a message to all channels in the same room, except the sender's. */
        get: function () {
            var _this = this;
            return {
                /**
                 * Emit a broadcasted message.
                 * @param eventName The event name.
                 * @param data The data to send.
                 */
                emit: function (eventName, data) {
                    var _a;
                    bridge_1.default.emit(constants_1.EVENTS.BROADCAST_MESSAGE, (_a = {}, _a[eventName] = data, _a), {
                        id: _this._id,
                        roomId: _this._roomId
                    });
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Forward a message to all channels in a specific room.
     * @param roomId The roomId.
     */
    ServerChannel.prototype.forward = function (roomId) {
        var _this = this;
        return {
            /**
             * Emit a forwarded message.
             * @param eventName The event name.
             * @param data The data to send.
             */
            emit: function (eventName, data) {
                var _a;
                bridge_1.default.emit(constants_1.EVENTS.FORWARD_MESSAGE, (_a = {}, _a[eventName] = data, _a), {
                    roomId: roomId,
                    id: _this._id
                });
            }
        };
    };
    /**
     * Emit a message to the channel.
     * @param eventName The event name.
     * @param data The data to send.
     */
    ServerChannel.prototype.emit = function (eventName, data) {
        if (data === void 0) { data = null; }
        this._emit(eventName, data);
    };
    ServerChannel.prototype._emit = function (eventName, data) {
        if (data === void 0) { data = null; }
        if (!this._roomId || this._roomId === this._roomId)
            if (!this._id || this._id === this._id) {
                sendMessage_1.default(this.dataChannel, eventName, data);
            }
    };
    Object.defineProperty(ServerChannel.prototype, "raw", {
        /** Send a raw message. */
        get: function () {
            var _this = this;
            return {
                /**
                 * Emit a raw message.
                 * @param rawMessage The raw message. Can be of type 'USVString | ArrayBuffer | ArrayBufferView'
                 */
                emit: function (rawMessage) { return _this.emit(constants_1.EVENTS.RAW_MESSAGE, rawMessage); }
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Listen for raw messages.
     * @param callback The event callback.
     */
    ServerChannel.prototype.onRaw = function (callback) {
        this.eventEmitter.on(constants_1.EVENTS.RAW_MESSAGE, function (rawMessage) {
            var cb = function (rawMessage) { return callback(rawMessage); };
            cb(rawMessage);
        });
    };
    /**
     * Listen for a message.
     * @param eventName The event name.
     * @param callback The event callback.
     */
    ServerChannel.prototype.on = function (eventName, callback) {
        this.eventEmitter.on(eventName, function (data, senderId) {
            if (senderId === void 0) { senderId = undefined; }
            var cb = function (data, senderId) { return callback(data, senderId); };
            cb(data, senderId);
        });
    };
    return ServerChannel;
}());
exports.default = ServerChannel;
//# sourceMappingURL=channel.js.map