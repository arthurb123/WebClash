import DefaultConnection from './defaultConnection';
import Channel from './channel';
import { ChannelId, ServerOptions } from '@geckos.io/common/lib/typings';
export default class WebRTCConnection extends DefaultConnection {
    peerConnection: RTCPeerConnection;
    channel: Channel;
    private options;
    constructor(id: ChannelId, serverOptions: ServerOptions);
    doOffer(): Promise<void>;
    readonly iceConnectionState: RTCIceConnectionState;
    readonly localDescription: {
        type?: undefined;
        sdp?: undefined;
    } | {
        type: RTCSdpType;
        sdp: string;
    };
    readonly remoteDescription: {
        type?: undefined;
        sdp?: undefined;
    } | {
        type: RTCSdpType;
        sdp: string;
    };
    readonly signalingState: RTCSignalingState;
    applyAnswer(answer: RTCSessionDescription): Promise<void>;
    toJSON: () => {
        iceConnectionState: RTCIceConnectionState;
        localDescription: {
            type?: undefined;
            sdp?: undefined;
        } | {
            type: RTCSdpType;
            sdp: string;
        };
        remoteDescription: {
            type?: undefined;
            sdp?: undefined;
        } | {
            type: RTCSdpType;
            sdp: string;
        };
        signalingState: RTCSignalingState;
        id: ChannelId;
        state: "open" | "closed";
    };
    descriptionToJSON(description: RTCSessionDescription | null, shouldDisableTrickleIce?: boolean): {
        type?: undefined;
        sdp?: undefined;
    } | {
        type: RTCSdpType;
        sdp: string;
    };
    disableTrickleIce(sdp: string): string;
    close(): void;
    waitUntilIceGatheringStateComplete(peerConnection: RTCPeerConnection, options: any): Promise<void>;
}
//# sourceMappingURL=webrtcConnection.d.ts.map